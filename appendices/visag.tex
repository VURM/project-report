\chapter{ViSaG comparison}

\gls{popc} \cite{popc} is a framework that provides C++ language extension, compiler and runtime to easily deploy applications to a computing grid. One of the core aspects of the framework is that existing code can easily be converted to a parallel executing version with the minimum amount of changes.

\gls{visag} \cite{visag} is a project that aims to add security to the execution of \gls{popc} applications by adding secure communication channels and virtualization to the runtime.

Virtualization was used for different reasons in \gls{visag} and \gls{vurm}: mainly security and sandboxing in the first and customization and dynamic resource reallocation in the second. Nonetheless, both project encountered some of the same problematics and solved them differently. This appendix aims to provide a short overview of the differently implemented solutions and how they relate one to the other.

Both \gls{visag} and \gls{vurm} use libvirt to access the main hypervisor functions. In the case of \gls{vurm}, this allows the integration with different hypervisors; the main reason to use libvirt was the provided abstraction layer, and thus the ability to swap hypervisors at will while guaranteeing an easy path to support the Palacios \gls{vmm} in the future. In the case of \gls{visag}, the main reason for the adoption of libvirt was the relatively simple interface it offered to access the VMWare ESX hypervisor, while the abstraction of different hypervisor was overshadowed by the implementation of some direct interactions with the ESX hypervisor as seen later in this appendix.

One of the first similar encountered problems is the retrieval of the \gls{ip} address from a newly spawned virtual machine. The \autoref{sec:ip-address-retrieval} of the \nameref{sec:remotevirt} chapter presents the different analyzed solutions to this problem. Both the solutions adopted by \gls{visag} and \gls{vurm} were presented in the above cited section: \gls{vurm} went down the serial to \gls{tcp} data exchange way while \gls{visag} chose to take advantage of the proprietary virtual machine tools provided by ESX and installed on the running domain. Each solution has its own advantages and drawbacks: the serial to \gls{tcp} data exchange adds more complexity to the application as an external \gls{tcp} server has to be put in place, while the proprietary \gls{vm} tools solution tightly couples the \gls{visag} implementation to a specific hypervisor.

Another key problem solved in different ways is the setup of the authentication credentials for the remote login through an \gls{ssh} connection. As done for the \gls{ip} address retrieval problem, different possible solutions were discussed in the \autoref{sec:pk-exchange} of the \nameref{sec:remotevirt} chapter. In this case, the authentication model specific to each project clearly identified the correct solution for it. When using the \gls{vurm} utility, the end users specifies a disk image to use to execute on its virtual cluster. This allows complete customization over the environment in which the different \gls{slurm} jobs will be executed. Differently, in the \gls{visag} case, the \gls{vm} disk image is provided during the setup phase and used for security and sandboxing purposes. This disk image is shared among all different users and each user wants to grant access to a running domain only to its own application. The key difference here is that all virtual machines on a \gls{vurm} system are accessed by the same entity (the \texttt{remotevirt} daemon) using a single key pair while on a \gls{visag} system each virtual machine is potentially accessed by different entities (the application which requested the creation of the \gls{vm}) using different key pairs.
In the case of \gls{vurm}, the installation of the public key into the \gls{vm} disk image is a requirement which has to be fulfilled by the user. In the case of \gls{visag}, the public key is copied to the virtual machine at runtime using an hypervisor specific feature.

The last difference between the two projects is the method used to spawn new virtual machines. In the case of \gls{vurm}, new virtual machines are spawned simultaneously as part of a new virtual cluster creation request; loosing some time to completely boot a new domain was considered an acceptable tradeoff given the relative infrequency of the operation. In the context of a \gls{visag} execution, \glspl{vm} have to be spawned more frequently and with lower latency. This requirement led to adopt a spawning technique based on a \gls{vm} snapshot, in which an already booted and suspended domain is resumed.
The resuming operation is faster compared to a full \gls{os} boot, but presents other disadvantages which had to be overcome, as, for example, the triggering of the negotiation of a new \gls{ip} address.
